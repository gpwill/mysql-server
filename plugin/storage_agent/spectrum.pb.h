// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spectrum.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_spectrum_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_spectrum_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_spectrum_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_spectrum_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_spectrum_2eproto;
namespace spectrum {
class AbortRequestMessage;
struct AbortRequestMessageDefaultTypeInternal;
extern AbortRequestMessageDefaultTypeInternal _AbortRequestMessage_default_instance_;
class AbortResponseMessage;
struct AbortResponseMessageDefaultTypeInternal;
extern AbortResponseMessageDefaultTypeInternal _AbortResponseMessage_default_instance_;
class AcceptRequestMessage;
struct AcceptRequestMessageDefaultTypeInternal;
extern AcceptRequestMessageDefaultTypeInternal _AcceptRequestMessage_default_instance_;
class AcceptResponseMessage;
struct AcceptResponseMessageDefaultTypeInternal;
extern AcceptResponseMessageDefaultTypeInternal _AcceptResponseMessage_default_instance_;
class CreateReplicaRequestMessage;
struct CreateReplicaRequestMessageDefaultTypeInternal;
extern CreateReplicaRequestMessageDefaultTypeInternal _CreateReplicaRequestMessage_default_instance_;
class CreateReplicaResponseMessage;
struct CreateReplicaResponseMessageDefaultTypeInternal;
extern CreateReplicaResponseMessageDefaultTypeInternal _CreateReplicaResponseMessage_default_instance_;
class CreateTableRequest;
struct CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableResponse;
struct CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class DataItemMessage;
struct DataItemMessageDefaultTypeInternal;
extern DataItemMessageDefaultTypeInternal _DataItemMessage_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class MDL;
struct MDLDefaultTypeInternal;
extern MDLDefaultTypeInternal _MDL_default_instance_;
class PrepareRequestMessage;
struct PrepareRequestMessageDefaultTypeInternal;
extern PrepareRequestMessageDefaultTypeInternal _PrepareRequestMessage_default_instance_;
class PrepareResponseMessage;
struct PrepareResponseMessageDefaultTypeInternal;
extern PrepareResponseMessageDefaultTypeInternal _PrepareResponseMessage_default_instance_;
class ProposalMessage;
struct ProposalMessageDefaultTypeInternal;
extern ProposalMessageDefaultTypeInternal _ProposalMessage_default_instance_;
class Row;
struct RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class Thread;
struct ThreadDefaultTypeInternal;
extern ThreadDefaultTypeInternal _Thread_default_instance_;
class UpdateEpochRequestMessage;
struct UpdateEpochRequestMessageDefaultTypeInternal;
extern UpdateEpochRequestMessageDefaultTypeInternal _UpdateEpochRequestMessage_default_instance_;
class UpdateEpochResponseMessage;
struct UpdateEpochResponseMessageDefaultTypeInternal;
extern UpdateEpochResponseMessageDefaultTypeInternal _UpdateEpochResponseMessage_default_instance_;
class UpdateRowRequest;
struct UpdateRowRequestDefaultTypeInternal;
extern UpdateRowRequestDefaultTypeInternal _UpdateRowRequest_default_instance_;
class UpdateRowResponse;
struct UpdateRowResponseDefaultTypeInternal;
extern UpdateRowResponseDefaultTypeInternal _UpdateRowResponse_default_instance_;
class WriteRowRequest;
struct WriteRowRequestDefaultTypeInternal;
extern WriteRowRequestDefaultTypeInternal _WriteRowRequest_default_instance_;
class WriteRowResponse;
struct WriteRowResponseDefaultTypeInternal;
extern WriteRowResponseDefaultTypeInternal _WriteRowResponse_default_instance_;
}  // namespace spectrum
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace spectrum {

// ===================================================================


// -------------------------------------------------------------------

class WriteRowResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.WriteRowResponse) */ {
 public:
  inline WriteRowResponse() : WriteRowResponse(nullptr) {}
  ~WriteRowResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WriteRowResponse(::google::protobuf::internal::ConstantInitialized);

  inline WriteRowResponse(const WriteRowResponse& from)
      : WriteRowResponse(nullptr, from) {}
  WriteRowResponse(WriteRowResponse&& from) noexcept
    : WriteRowResponse() {
    *this = ::std::move(from);
  }

  inline WriteRowResponse& operator=(const WriteRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRowResponse& operator=(WriteRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRowResponse* internal_default_instance() {
    return reinterpret_cast<const WriteRowResponse*>(
               &_WriteRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WriteRowResponse& a, WriteRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRowResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRowResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRowResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteRowResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WriteRowResponse& from) {
    WriteRowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WriteRowResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.WriteRowResponse";
  }
  protected:
  explicit WriteRowResponse(::google::protobuf::Arena* arena);
  WriteRowResponse(::google::protobuf::Arena* arena, const WriteRowResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsertIdFieldNumber = 1,
  };
  // int64 insert_id = 1;
  void clear_insert_id() ;
  ::int64_t insert_id() const;
  void set_insert_id(::int64_t value);

  private:
  ::int64_t _internal_insert_id() const;
  void _internal_set_insert_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.WriteRowResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t insert_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class UpdateRowResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:spectrum.UpdateRowResponse) */ {
 public:
  inline UpdateRowResponse() : UpdateRowResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRowResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateRowResponse(const UpdateRowResponse& from)
      : UpdateRowResponse(nullptr, from) {}
  UpdateRowResponse(UpdateRowResponse&& from) noexcept
    : UpdateRowResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRowResponse& operator=(const UpdateRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRowResponse& operator=(UpdateRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRowResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRowResponse*>(
               &_UpdateRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateRowResponse& a, UpdateRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRowResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRowResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRowResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRowResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRowResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.UpdateRowResponse";
  }
  protected:
  explicit UpdateRowResponse(::google::protobuf::Arena* arena);
  UpdateRowResponse(::google::protobuf::Arena* arena, const UpdateRowResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spectrum.UpdateRowResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class UpdateEpochResponseMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.UpdateEpochResponseMessage) */ {
 public:
  inline UpdateEpochResponseMessage() : UpdateEpochResponseMessage(nullptr) {}
  ~UpdateEpochResponseMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateEpochResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline UpdateEpochResponseMessage(const UpdateEpochResponseMessage& from)
      : UpdateEpochResponseMessage(nullptr, from) {}
  UpdateEpochResponseMessage(UpdateEpochResponseMessage&& from) noexcept
    : UpdateEpochResponseMessage() {
    *this = ::std::move(from);
  }

  inline UpdateEpochResponseMessage& operator=(const UpdateEpochResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEpochResponseMessage& operator=(UpdateEpochResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEpochResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEpochResponseMessage* internal_default_instance() {
    return reinterpret_cast<const UpdateEpochResponseMessage*>(
               &_UpdateEpochResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateEpochResponseMessage& a, UpdateEpochResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEpochResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEpochResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEpochResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEpochResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateEpochResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateEpochResponseMessage& from) {
    UpdateEpochResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateEpochResponseMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.UpdateEpochResponseMessage";
  }
  protected:
  explicit UpdateEpochResponseMessage(::google::protobuf::Arena* arena);
  UpdateEpochResponseMessage(::google::protobuf::Arena* arena, const UpdateEpochResponseMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
  };
  // int64 epoch = 1;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.UpdateEpochResponseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t epoch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class UpdateEpochRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.UpdateEpochRequestMessage) */ {
 public:
  inline UpdateEpochRequestMessage() : UpdateEpochRequestMessage(nullptr) {}
  ~UpdateEpochRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateEpochRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline UpdateEpochRequestMessage(const UpdateEpochRequestMessage& from)
      : UpdateEpochRequestMessage(nullptr, from) {}
  UpdateEpochRequestMessage(UpdateEpochRequestMessage&& from) noexcept
    : UpdateEpochRequestMessage() {
    *this = ::std::move(from);
  }

  inline UpdateEpochRequestMessage& operator=(const UpdateEpochRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEpochRequestMessage& operator=(UpdateEpochRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEpochRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEpochRequestMessage* internal_default_instance() {
    return reinterpret_cast<const UpdateEpochRequestMessage*>(
               &_UpdateEpochRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateEpochRequestMessage& a, UpdateEpochRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEpochRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEpochRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEpochRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEpochRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateEpochRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateEpochRequestMessage& from) {
    UpdateEpochRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateEpochRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.UpdateEpochRequestMessage";
  }
  protected:
  explicit UpdateEpochRequestMessage(::google::protobuf::Arena* arena);
  UpdateEpochRequestMessage(::google::protobuf::Arena* arena, const UpdateEpochRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kEpochFieldNumber = 3,
    kReplicaIdFieldNumber = 2,
  };
  // string namespace = 1;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // int64 epoch = 3;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // int32 replicaId = 2;
  void clear_replicaid() ;
  ::int32_t replicaid() const;
  void set_replicaid(::int32_t value);

  private:
  ::int32_t _internal_replicaid() const;
  void _internal_set_replicaid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.UpdateEpochRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::int64_t epoch_;
    ::int32_t replicaid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class ProposalMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.ProposalMessage) */ {
 public:
  inline ProposalMessage() : ProposalMessage(nullptr) {}
  ~ProposalMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProposalMessage(::google::protobuf::internal::ConstantInitialized);

  inline ProposalMessage(const ProposalMessage& from)
      : ProposalMessage(nullptr, from) {}
  ProposalMessage(ProposalMessage&& from) noexcept
    : ProposalMessage() {
    *this = ::std::move(from);
  }

  inline ProposalMessage& operator=(const ProposalMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalMessage& operator=(ProposalMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalMessage* internal_default_instance() {
    return reinterpret_cast<const ProposalMessage*>(
               &_ProposalMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ProposalMessage& a, ProposalMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProposalMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProposalMessage& from) {
    ProposalMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProposalMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.ProposalMessage";
  }
  protected:
  explicit ProposalMessage(::google::protobuf::Arena* arena);
  ProposalMessage(::google::protobuf::Arena* arena, const ProposalMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kParentProposalFieldNumber = 6,
    kVersionFieldNumber = 4,
    kSequenceNumberFieldNumber = 5,
    kIsNextFieldNumber = 3,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // optional .spectrum.ProposalMessage parentProposal = 6;
  bool has_parentproposal() const;
  void clear_parentproposal() ;
  const ::spectrum::ProposalMessage& parentproposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_parentproposal();
  ::spectrum::ProposalMessage* mutable_parentproposal();
  void set_allocated_parentproposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_parentproposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_parentproposal();

  private:
  const ::spectrum::ProposalMessage& _internal_parentproposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_parentproposal();

  public:
  // int64 version = 4;
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // int64 sequenceNumber = 5;
  void clear_sequencenumber() ;
  ::int64_t sequencenumber() const;
  void set_sequencenumber(::int64_t value);

  private:
  ::int64_t _internal_sequencenumber() const;
  void _internal_set_sequencenumber(::int64_t value);

  public:
  // optional bool isNext = 3;
  bool has_isnext() const;
  void clear_isnext() ;
  bool isnext() const;
  void set_isnext(bool value);

  private:
  bool _internal_isnext() const;
  void _internal_set_isnext(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.ProposalMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::spectrum::ProposalMessage* parentproposal_;
    ::int64_t version_;
    ::int64_t sequencenumber_;
    bool isnext_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class MDL final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.MDL) */ {
 public:
  inline MDL() : MDL(nullptr) {}
  ~MDL() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MDL(::google::protobuf::internal::ConstantInitialized);

  inline MDL(const MDL& from)
      : MDL(nullptr, from) {}
  MDL(MDL&& from) noexcept
    : MDL() {
    *this = ::std::move(from);
  }

  inline MDL& operator=(const MDL& from) {
    CopyFrom(from);
    return *this;
  }
  inline MDL& operator=(MDL&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MDL& default_instance() {
    return *internal_default_instance();
  }
  static inline const MDL* internal_default_instance() {
    return reinterpret_cast<const MDL*>(
               &_MDL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MDL& a, MDL& b) {
    a.Swap(&b);
  }
  inline void Swap(MDL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MDL* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MDL* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MDL>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MDL& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MDL& from) {
    MDL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MDL* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.MDL";
  }
  protected:
  explicit MDL(::google::protobuf::Arena* arena);
  MDL(::google::protobuf::Arena* arena, const MDL& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 2,
    kTableFieldNumber = 3,
    kColumnFieldNumber = 4,
    kNamespaceFieldNumber = 1,
    kTypeFieldNumber = 5,
  };
  // string schema = 2;
  void clear_schema() ;
  const std::string& schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema(Arg_&& arg, Args_... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* value);

  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(
      const std::string& value);
  std::string* _internal_mutable_schema();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(
      const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // string column = 4;
  void clear_column() ;
  const std::string& column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column(Arg_&& arg, Args_... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* value);

  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(
      const std::string& value);
  std::string* _internal_mutable_column();

  public:
  // int32 namespace = 1;
  void clear_namespace_() ;
  ::int32_t namespace_() const;
  void set_namespace_(::int32_t value);

  private:
  ::int32_t _internal_namespace_() const;
  void _internal_set_namespace_(::int32_t value);

  public:
  // int32 type = 5;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.MDL)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr schema_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    ::google::protobuf::internal::ArenaStringPtr column_;
    ::int32_t namespace__;
    ::int32_t type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class Field final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Field(::google::protobuf::internal::ConstantInitialized);

  inline Field(const Field& from)
      : Field(nullptr, from) {}
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Field& from) {
    Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Field* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.Field";
  }
  protected:
  explicit Field(::google::protobuf::Arena* arena);
  Field(::google::protobuf::Arena* arena, const Field& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kIsNullFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bytes value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // bool is_null = 3;
  void clear_is_null() ;
  bool is_null() const;
  void set_is_null(bool value);

  private:
  bool _internal_is_null() const;
  void _internal_set_is_null(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.Field)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      27, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    bool is_null_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class DataItemMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.DataItemMessage) */ {
 public:
  inline DataItemMessage() : DataItemMessage(nullptr) {}
  ~DataItemMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataItemMessage(::google::protobuf::internal::ConstantInitialized);

  inline DataItemMessage(const DataItemMessage& from)
      : DataItemMessage(nullptr, from) {}
  DataItemMessage(DataItemMessage&& from) noexcept
    : DataItemMessage() {
    *this = ::std::move(from);
  }

  inline DataItemMessage& operator=(const DataItemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataItemMessage& operator=(DataItemMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataItemMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataItemMessage* internal_default_instance() {
    return reinterpret_cast<const DataItemMessage*>(
               &_DataItemMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DataItemMessage& a, DataItemMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataItemMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataItemMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataItemMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataItemMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataItemMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataItemMessage& from) {
    DataItemMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataItemMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.DataItemMessage";
  }
  protected:
  explicit DataItemMessage(::google::protobuf::Arena* arena);
  DataItemMessage(::google::protobuf::Arena* arena, const DataItemMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kVersionFieldNumber = 5,
    kIsNextFieldNumber = 4,
  };
  // string namespace = 1;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // string key = 2;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string value = 3;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int64 version = 5;
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // optional bool isNext = 4;
  bool has_isnext() const;
  void clear_isnext() ;
  bool isnext() const;
  void set_isnext(bool value);

  private:
  bool _internal_isnext() const;
  void _internal_set_isnext(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.DataItemMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::int64_t version_;
    bool isnext_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class CreateTableResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:spectrum.CreateTableResponse) */ {
 public:
  inline CreateTableResponse() : CreateTableResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTableResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateTableResponse(const CreateTableResponse& from)
      : CreateTableResponse(nullptr, from) {}
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateTableResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateTableResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.CreateTableResponse";
  }
  protected:
  explicit CreateTableResponse(::google::protobuf::Arena* arena);
  CreateTableResponse(::google::protobuf::Arena* arena, const CreateTableResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spectrum.CreateTableResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class CreateReplicaResponseMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.CreateReplicaResponseMessage) */ {
 public:
  inline CreateReplicaResponseMessage() : CreateReplicaResponseMessage(nullptr) {}
  ~CreateReplicaResponseMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateReplicaResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline CreateReplicaResponseMessage(const CreateReplicaResponseMessage& from)
      : CreateReplicaResponseMessage(nullptr, from) {}
  CreateReplicaResponseMessage(CreateReplicaResponseMessage&& from) noexcept
    : CreateReplicaResponseMessage() {
    *this = ::std::move(from);
  }

  inline CreateReplicaResponseMessage& operator=(const CreateReplicaResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateReplicaResponseMessage& operator=(CreateReplicaResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateReplicaResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateReplicaResponseMessage* internal_default_instance() {
    return reinterpret_cast<const CreateReplicaResponseMessage*>(
               &_CreateReplicaResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateReplicaResponseMessage& a, CreateReplicaResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateReplicaResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateReplicaResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateReplicaResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateReplicaResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateReplicaResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateReplicaResponseMessage& from) {
    CreateReplicaResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateReplicaResponseMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.CreateReplicaResponseMessage";
  }
  protected:
  explicit CreateReplicaResponseMessage(::google::protobuf::Arena* arena);
  CreateReplicaResponseMessage(::google::protobuf::Arena* arena, const CreateReplicaResponseMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptorIdFieldNumber = 1,
  };
  // string acceptorId = 1;
  void clear_acceptorid() ;
  const std::string& acceptorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acceptorid(Arg_&& arg, Args_... args);
  std::string* mutable_acceptorid();
  PROTOBUF_NODISCARD std::string* release_acceptorid();
  void set_allocated_acceptorid(std::string* value);

  private:
  const std::string& _internal_acceptorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acceptorid(
      const std::string& value);
  std::string* _internal_mutable_acceptorid();

  public:
  // @@protoc_insertion_point(class_scope:spectrum.CreateReplicaResponseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr acceptorid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class CreateReplicaRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.CreateReplicaRequestMessage) */ {
 public:
  inline CreateReplicaRequestMessage() : CreateReplicaRequestMessage(nullptr) {}
  ~CreateReplicaRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateReplicaRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline CreateReplicaRequestMessage(const CreateReplicaRequestMessage& from)
      : CreateReplicaRequestMessage(nullptr, from) {}
  CreateReplicaRequestMessage(CreateReplicaRequestMessage&& from) noexcept
    : CreateReplicaRequestMessage() {
    *this = ::std::move(from);
  }

  inline CreateReplicaRequestMessage& operator=(const CreateReplicaRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateReplicaRequestMessage& operator=(CreateReplicaRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateReplicaRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateReplicaRequestMessage* internal_default_instance() {
    return reinterpret_cast<const CreateReplicaRequestMessage*>(
               &_CreateReplicaRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateReplicaRequestMessage& a, CreateReplicaRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateReplicaRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateReplicaRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateReplicaRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateReplicaRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateReplicaRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateReplicaRequestMessage& from) {
    CreateReplicaRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateReplicaRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.CreateReplicaRequestMessage";
  }
  protected:
  explicit CreateReplicaRequestMessage(::google::protobuf::Arena* arena);
  CreateReplicaRequestMessage(::google::protobuf::Arena* arena, const CreateReplicaRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kReplicaIdFieldNumber = 2,
  };
  // string namespace = 1;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // int32 replicaId = 2;
  void clear_replicaid() ;
  ::int32_t replicaid() const;
  void set_replicaid(::int32_t value);

  private:
  ::int32_t _internal_replicaid() const;
  void _internal_set_replicaid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.CreateReplicaRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::int32_t replicaid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class AbortResponseMessage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:spectrum.AbortResponseMessage) */ {
 public:
  inline AbortResponseMessage() : AbortResponseMessage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AbortResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline AbortResponseMessage(const AbortResponseMessage& from)
      : AbortResponseMessage(nullptr, from) {}
  AbortResponseMessage(AbortResponseMessage&& from) noexcept
    : AbortResponseMessage() {
    *this = ::std::move(from);
  }

  inline AbortResponseMessage& operator=(const AbortResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortResponseMessage& operator=(AbortResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbortResponseMessage* internal_default_instance() {
    return reinterpret_cast<const AbortResponseMessage*>(
               &_AbortResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AbortResponseMessage& a, AbortResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbortResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbortResponseMessage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AbortResponseMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AbortResponseMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.AbortResponseMessage";
  }
  protected:
  explicit AbortResponseMessage(::google::protobuf::Arena* arena);
  AbortResponseMessage(::google::protobuf::Arena* arena, const AbortResponseMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spectrum.AbortResponseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class Thread final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.Thread) */ {
 public:
  inline Thread() : Thread(nullptr) {}
  ~Thread() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Thread(::google::protobuf::internal::ConstantInitialized);

  inline Thread(const Thread& from)
      : Thread(nullptr, from) {}
  Thread(Thread&& from) noexcept
    : Thread() {
    *this = ::std::move(from);
  }

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Thread& operator=(Thread&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Thread& default_instance() {
    return *internal_default_instance();
  }
  static inline const Thread* internal_default_instance() {
    return reinterpret_cast<const Thread*>(
               &_Thread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Thread& a, Thread& b) {
    a.Swap(&b);
  }
  inline void Swap(Thread* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Thread* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Thread* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Thread>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Thread& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Thread& from) {
    Thread::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Thread* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.Thread";
  }
  protected:
  explicit Thread(::google::protobuf::Arena* arena);
  Thread(::google::protobuf::Arena* arena, const Thread& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMdlListFieldNumber = 1,
  };
  // repeated .spectrum.MDL mdl_list = 1;
  int mdl_list_size() const;
  private:
  int _internal_mdl_list_size() const;

  public:
  void clear_mdl_list() ;
  ::spectrum::MDL* mutable_mdl_list(int index);
  ::google::protobuf::RepeatedPtrField< ::spectrum::MDL >*
      mutable_mdl_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::spectrum::MDL>& _internal_mdl_list() const;
  ::google::protobuf::RepeatedPtrField<::spectrum::MDL>* _internal_mutable_mdl_list();
  public:
  const ::spectrum::MDL& mdl_list(int index) const;
  ::spectrum::MDL* add_mdl_list();
  const ::google::protobuf::RepeatedPtrField< ::spectrum::MDL >&
      mdl_list() const;
  // @@protoc_insertion_point(class_scope:spectrum.Thread)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::spectrum::MDL > mdl_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class Row final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.Row) */ {
 public:
  inline Row() : Row(nullptr) {}
  ~Row() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Row(::google::protobuf::internal::ConstantInitialized);

  inline Row(const Row& from)
      : Row(nullptr, from) {}
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline Row& operator=(Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }
  inline void Swap(Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Row* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Row* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Row>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Row& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Row& from) {
    Row::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Row* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.Row";
  }
  protected:
  explicit Row(::google::protobuf::Arena* arena);
  Row(::google::protobuf::Arena* arena, const Row& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 3,
  };
  // repeated .spectrum.Field fields = 3;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::spectrum::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::spectrum::Field >*
      mutable_fields();
  private:
  const ::google::protobuf::RepeatedPtrField<::spectrum::Field>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::spectrum::Field>* _internal_mutable_fields();
  public:
  const ::spectrum::Field& fields(int index) const;
  ::spectrum::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::spectrum::Field >&
      fields() const;
  // @@protoc_insertion_point(class_scope:spectrum.Row)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::spectrum::Field > fields_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class PrepareResponseMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.PrepareResponseMessage) */ {
 public:
  inline PrepareResponseMessage() : PrepareResponseMessage(nullptr) {}
  ~PrepareResponseMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline PrepareResponseMessage(const PrepareResponseMessage& from)
      : PrepareResponseMessage(nullptr, from) {}
  PrepareResponseMessage(PrepareResponseMessage&& from) noexcept
    : PrepareResponseMessage() {
    *this = ::std::move(from);
  }

  inline PrepareResponseMessage& operator=(const PrepareResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareResponseMessage& operator=(PrepareResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareResponseMessage* internal_default_instance() {
    return reinterpret_cast<const PrepareResponseMessage*>(
               &_PrepareResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PrepareResponseMessage& a, PrepareResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrepareResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PrepareResponseMessage& from) {
    PrepareResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrepareResponseMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.PrepareResponseMessage";
  }
  protected:
  explicit PrepareResponseMessage(::google::protobuf::Arena* arena);
  PrepareResponseMessage(::google::protobuf::Arena* arena, const PrepareResponseMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreparedProposalFieldNumber = 2,
    kAcceptedProposalFieldNumber = 3,
    kEpochFieldNumber = 4,
    kMaxSequenceNumberFieldNumber = 5,
    kPreparedFieldNumber = 1,
  };
  // .spectrum.ProposalMessage preparedProposal = 2;
  bool has_preparedproposal() const;
  void clear_preparedproposal() ;
  const ::spectrum::ProposalMessage& preparedproposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_preparedproposal();
  ::spectrum::ProposalMessage* mutable_preparedproposal();
  void set_allocated_preparedproposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_preparedproposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_preparedproposal();

  private:
  const ::spectrum::ProposalMessage& _internal_preparedproposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_preparedproposal();

  public:
  // .spectrum.ProposalMessage acceptedProposal = 3;
  bool has_acceptedproposal() const;
  void clear_acceptedproposal() ;
  const ::spectrum::ProposalMessage& acceptedproposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_acceptedproposal();
  ::spectrum::ProposalMessage* mutable_acceptedproposal();
  void set_allocated_acceptedproposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_acceptedproposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_acceptedproposal();

  private:
  const ::spectrum::ProposalMessage& _internal_acceptedproposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_acceptedproposal();

  public:
  // int64 epoch = 4;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // int64 maxSequenceNumber = 5;
  void clear_maxsequencenumber() ;
  ::int64_t maxsequencenumber() const;
  void set_maxsequencenumber(::int64_t value);

  private:
  ::int64_t _internal_maxsequencenumber() const;
  void _internal_set_maxsequencenumber(::int64_t value);

  public:
  // bool prepared = 1;
  void clear_prepared() ;
  bool prepared() const;
  void set_prepared(bool value);

  private:
  bool _internal_prepared() const;
  void _internal_set_prepared(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.PrepareResponseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::spectrum::ProposalMessage* preparedproposal_;
    ::spectrum::ProposalMessage* acceptedproposal_;
    ::int64_t epoch_;
    ::int64_t maxsequencenumber_;
    bool prepared_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class PrepareRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.PrepareRequestMessage) */ {
 public:
  inline PrepareRequestMessage() : PrepareRequestMessage(nullptr) {}
  ~PrepareRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline PrepareRequestMessage(const PrepareRequestMessage& from)
      : PrepareRequestMessage(nullptr, from) {}
  PrepareRequestMessage(PrepareRequestMessage&& from) noexcept
    : PrepareRequestMessage() {
    *this = ::std::move(from);
  }

  inline PrepareRequestMessage& operator=(const PrepareRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareRequestMessage& operator=(PrepareRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareRequestMessage* internal_default_instance() {
    return reinterpret_cast<const PrepareRequestMessage*>(
               &_PrepareRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PrepareRequestMessage& a, PrepareRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrepareRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PrepareRequestMessage& from) {
    PrepareRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrepareRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.PrepareRequestMessage";
  }
  protected:
  explicit PrepareRequestMessage(::google::protobuf::Arena* arena);
  PrepareRequestMessage(::google::protobuf::Arena* arena, const PrepareRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptorIdFieldNumber = 1,
    kProposalFieldNumber = 3,
    kEpochFieldNumber = 2,
  };
  // string acceptorId = 1;
  void clear_acceptorid() ;
  const std::string& acceptorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acceptorid(Arg_&& arg, Args_... args);
  std::string* mutable_acceptorid();
  PROTOBUF_NODISCARD std::string* release_acceptorid();
  void set_allocated_acceptorid(std::string* value);

  private:
  const std::string& _internal_acceptorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acceptorid(
      const std::string& value);
  std::string* _internal_mutable_acceptorid();

  public:
  // .spectrum.ProposalMessage proposal = 3;
  bool has_proposal() const;
  void clear_proposal() ;
  const ::spectrum::ProposalMessage& proposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_proposal();
  ::spectrum::ProposalMessage* mutable_proposal();
  void set_allocated_proposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_proposal();

  private:
  const ::spectrum::ProposalMessage& _internal_proposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_proposal();

  public:
  // int64 epoch = 2;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.PrepareRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr acceptorid_;
    ::spectrum::ProposalMessage* proposal_;
    ::int64_t epoch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class AcceptResponseMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.AcceptResponseMessage) */ {
 public:
  inline AcceptResponseMessage() : AcceptResponseMessage(nullptr) {}
  ~AcceptResponseMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline AcceptResponseMessage(const AcceptResponseMessage& from)
      : AcceptResponseMessage(nullptr, from) {}
  AcceptResponseMessage(AcceptResponseMessage&& from) noexcept
    : AcceptResponseMessage() {
    *this = ::std::move(from);
  }

  inline AcceptResponseMessage& operator=(const AcceptResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptResponseMessage& operator=(AcceptResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptResponseMessage* internal_default_instance() {
    return reinterpret_cast<const AcceptResponseMessage*>(
               &_AcceptResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AcceptResponseMessage& a, AcceptResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcceptResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AcceptResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AcceptResponseMessage& from) {
    AcceptResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AcceptResponseMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.AcceptResponseMessage";
  }
  protected:
  explicit AcceptResponseMessage(::google::protobuf::Arena* arena);
  AcceptResponseMessage(::google::protobuf::Arena* arena, const AcceptResponseMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreparedProposalFieldNumber = 2,
    kAcceptedProposalFieldNumber = 3,
    kEpochFieldNumber = 4,
    kMaxSequenceNumberFieldNumber = 5,
    kAcceptedFieldNumber = 1,
  };
  // .spectrum.ProposalMessage preparedProposal = 2;
  bool has_preparedproposal() const;
  void clear_preparedproposal() ;
  const ::spectrum::ProposalMessage& preparedproposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_preparedproposal();
  ::spectrum::ProposalMessage* mutable_preparedproposal();
  void set_allocated_preparedproposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_preparedproposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_preparedproposal();

  private:
  const ::spectrum::ProposalMessage& _internal_preparedproposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_preparedproposal();

  public:
  // .spectrum.ProposalMessage acceptedProposal = 3;
  bool has_acceptedproposal() const;
  void clear_acceptedproposal() ;
  const ::spectrum::ProposalMessage& acceptedproposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_acceptedproposal();
  ::spectrum::ProposalMessage* mutable_acceptedproposal();
  void set_allocated_acceptedproposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_acceptedproposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_acceptedproposal();

  private:
  const ::spectrum::ProposalMessage& _internal_acceptedproposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_acceptedproposal();

  public:
  // int64 epoch = 4;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // int64 maxSequenceNumber = 5;
  void clear_maxsequencenumber() ;
  ::int64_t maxsequencenumber() const;
  void set_maxsequencenumber(::int64_t value);

  private:
  ::int64_t _internal_maxsequencenumber() const;
  void _internal_set_maxsequencenumber(::int64_t value);

  public:
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.AcceptResponseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::spectrum::ProposalMessage* preparedproposal_;
    ::spectrum::ProposalMessage* acceptedproposal_;
    ::int64_t epoch_;
    ::int64_t maxsequencenumber_;
    bool accepted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class AcceptRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.AcceptRequestMessage) */ {
 public:
  inline AcceptRequestMessage() : AcceptRequestMessage(nullptr) {}
  ~AcceptRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline AcceptRequestMessage(const AcceptRequestMessage& from)
      : AcceptRequestMessage(nullptr, from) {}
  AcceptRequestMessage(AcceptRequestMessage&& from) noexcept
    : AcceptRequestMessage() {
    *this = ::std::move(from);
  }

  inline AcceptRequestMessage& operator=(const AcceptRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptRequestMessage& operator=(AcceptRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptRequestMessage* internal_default_instance() {
    return reinterpret_cast<const AcceptRequestMessage*>(
               &_AcceptRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AcceptRequestMessage& a, AcceptRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcceptRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AcceptRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AcceptRequestMessage& from) {
    AcceptRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AcceptRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.AcceptRequestMessage";
  }
  protected:
  explicit AcceptRequestMessage(::google::protobuf::Arena* arena);
  AcceptRequestMessage(::google::protobuf::Arena* arena, const AcceptRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptorIdFieldNumber = 1,
    kProposalFieldNumber = 3,
    kEpochFieldNumber = 2,
  };
  // string acceptorId = 1;
  void clear_acceptorid() ;
  const std::string& acceptorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acceptorid(Arg_&& arg, Args_... args);
  std::string* mutable_acceptorid();
  PROTOBUF_NODISCARD std::string* release_acceptorid();
  void set_allocated_acceptorid(std::string* value);

  private:
  const std::string& _internal_acceptorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acceptorid(
      const std::string& value);
  std::string* _internal_mutable_acceptorid();

  public:
  // .spectrum.ProposalMessage proposal = 3;
  bool has_proposal() const;
  void clear_proposal() ;
  const ::spectrum::ProposalMessage& proposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_proposal();
  ::spectrum::ProposalMessage* mutable_proposal();
  void set_allocated_proposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_proposal();

  private:
  const ::spectrum::ProposalMessage& _internal_proposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_proposal();

  public:
  // int64 epoch = 2;
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.AcceptRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr acceptorid_;
    ::spectrum::ProposalMessage* proposal_;
    ::int64_t epoch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class AbortRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.AbortRequestMessage) */ {
 public:
  inline AbortRequestMessage() : AbortRequestMessage(nullptr) {}
  ~AbortRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AbortRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline AbortRequestMessage(const AbortRequestMessage& from)
      : AbortRequestMessage(nullptr, from) {}
  AbortRequestMessage(AbortRequestMessage&& from) noexcept
    : AbortRequestMessage() {
    *this = ::std::move(from);
  }

  inline AbortRequestMessage& operator=(const AbortRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortRequestMessage& operator=(AbortRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbortRequestMessage* internal_default_instance() {
    return reinterpret_cast<const AbortRequestMessage*>(
               &_AbortRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AbortRequestMessage& a, AbortRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbortRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbortRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbortRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AbortRequestMessage& from) {
    AbortRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AbortRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.AbortRequestMessage";
  }
  protected:
  explicit AbortRequestMessage(::google::protobuf::Arena* arena);
  AbortRequestMessage(::google::protobuf::Arena* arena, const AbortRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptorIdFieldNumber = 1,
    kProposalFieldNumber = 2,
  };
  // string acceptorId = 1;
  void clear_acceptorid() ;
  const std::string& acceptorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acceptorid(Arg_&& arg, Args_... args);
  std::string* mutable_acceptorid();
  PROTOBUF_NODISCARD std::string* release_acceptorid();
  void set_allocated_acceptorid(std::string* value);

  private:
  const std::string& _internal_acceptorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acceptorid(
      const std::string& value);
  std::string* _internal_mutable_acceptorid();

  public:
  // .spectrum.ProposalMessage proposal = 2;
  bool has_proposal() const;
  void clear_proposal() ;
  const ::spectrum::ProposalMessage& proposal() const;
  PROTOBUF_NODISCARD ::spectrum::ProposalMessage* release_proposal();
  ::spectrum::ProposalMessage* mutable_proposal();
  void set_allocated_proposal(::spectrum::ProposalMessage* value);
  void unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value);
  ::spectrum::ProposalMessage* unsafe_arena_release_proposal();

  private:
  const ::spectrum::ProposalMessage& _internal_proposal() const;
  ::spectrum::ProposalMessage* _internal_mutable_proposal();

  public:
  // @@protoc_insertion_point(class_scope:spectrum.AbortRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr acceptorid_;
    ::spectrum::ProposalMessage* proposal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class WriteRowRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.WriteRowRequest) */ {
 public:
  inline WriteRowRequest() : WriteRowRequest(nullptr) {}
  ~WriteRowRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WriteRowRequest(::google::protobuf::internal::ConstantInitialized);

  inline WriteRowRequest(const WriteRowRequest& from)
      : WriteRowRequest(nullptr, from) {}
  WriteRowRequest(WriteRowRequest&& from) noexcept
    : WriteRowRequest() {
    *this = ::std::move(from);
  }

  inline WriteRowRequest& operator=(const WriteRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRowRequest& operator=(WriteRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRowRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRowRequest*>(
               &_WriteRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WriteRowRequest& a, WriteRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRowRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRowRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRowRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteRowRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WriteRowRequest& from) {
    WriteRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WriteRowRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.WriteRowRequest";
  }
  protected:
  explicit WriteRowRequest(::google::protobuf::Arena* arena);
  WriteRowRequest(::google::protobuf::Arena* arena, const WriteRowRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 2,
    kTableFieldNumber = 3,
    kThreadFieldNumber = 1,
    kRowFieldNumber = 4,
    kAutoincFieldHasExplicitNonNullValueFieldNumber = 5,
  };
  // string database = 2;
  void clear_database() ;
  const std::string& database() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_database(Arg_&& arg, Args_... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* value);

  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(
      const std::string& value);
  std::string* _internal_mutable_database();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(
      const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // .spectrum.Thread thread = 1;
  bool has_thread() const;
  void clear_thread() ;
  const ::spectrum::Thread& thread() const;
  PROTOBUF_NODISCARD ::spectrum::Thread* release_thread();
  ::spectrum::Thread* mutable_thread();
  void set_allocated_thread(::spectrum::Thread* value);
  void unsafe_arena_set_allocated_thread(::spectrum::Thread* value);
  ::spectrum::Thread* unsafe_arena_release_thread();

  private:
  const ::spectrum::Thread& _internal_thread() const;
  ::spectrum::Thread* _internal_mutable_thread();

  public:
  // .spectrum.Row row = 4;
  bool has_row() const;
  void clear_row() ;
  const ::spectrum::Row& row() const;
  PROTOBUF_NODISCARD ::spectrum::Row* release_row();
  ::spectrum::Row* mutable_row();
  void set_allocated_row(::spectrum::Row* value);
  void unsafe_arena_set_allocated_row(::spectrum::Row* value);
  ::spectrum::Row* unsafe_arena_release_row();

  private:
  const ::spectrum::Row& _internal_row() const;
  ::spectrum::Row* _internal_mutable_row();

  public:
  // bool autoinc_field_has_explicit_non_null_value = 5;
  void clear_autoinc_field_has_explicit_non_null_value() ;
  bool autoinc_field_has_explicit_non_null_value() const;
  void set_autoinc_field_has_explicit_non_null_value(bool value);

  private:
  bool _internal_autoinc_field_has_explicit_non_null_value() const;
  void _internal_set_autoinc_field_has_explicit_non_null_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.WriteRowRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr database_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    ::spectrum::Thread* thread_;
    ::spectrum::Row* row_;
    bool autoinc_field_has_explicit_non_null_value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class UpdateRowRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.UpdateRowRequest) */ {
 public:
  inline UpdateRowRequest() : UpdateRowRequest(nullptr) {}
  ~UpdateRowRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRowRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateRowRequest(const UpdateRowRequest& from)
      : UpdateRowRequest(nullptr, from) {}
  UpdateRowRequest(UpdateRowRequest&& from) noexcept
    : UpdateRowRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRowRequest& operator=(const UpdateRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRowRequest& operator=(UpdateRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRowRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRowRequest*>(
               &_UpdateRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateRowRequest& a, UpdateRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRowRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRowRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRowRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRowRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateRowRequest& from) {
    UpdateRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateRowRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.UpdateRowRequest";
  }
  protected:
  explicit UpdateRowRequest(::google::protobuf::Arena* arena);
  UpdateRowRequest(::google::protobuf::Arena* arena, const UpdateRowRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kTableFieldNumber = 2,
    kRowFieldNumber = 3,
    kAutoincFieldHasExplicitNonNullValueFieldNumber = 4,
  };
  // string database = 1;
  void clear_database() ;
  const std::string& database() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_database(Arg_&& arg, Args_... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* value);

  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(
      const std::string& value);
  std::string* _internal_mutable_database();

  public:
  // string table = 2;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(
      const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // .spectrum.Row row = 3;
  bool has_row() const;
  void clear_row() ;
  const ::spectrum::Row& row() const;
  PROTOBUF_NODISCARD ::spectrum::Row* release_row();
  ::spectrum::Row* mutable_row();
  void set_allocated_row(::spectrum::Row* value);
  void unsafe_arena_set_allocated_row(::spectrum::Row* value);
  ::spectrum::Row* unsafe_arena_release_row();

  private:
  const ::spectrum::Row& _internal_row() const;
  ::spectrum::Row* _internal_mutable_row();

  public:
  // bool autoinc_field_has_explicit_non_null_value = 4;
  void clear_autoinc_field_has_explicit_non_null_value() ;
  bool autoinc_field_has_explicit_non_null_value() const;
  void set_autoinc_field_has_explicit_non_null_value(bool value);

  private:
  bool _internal_autoinc_field_has_explicit_non_null_value() const;
  void _internal_set_autoinc_field_has_explicit_non_null_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:spectrum.UpdateRowRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr database_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    ::spectrum::Row* row_;
    bool autoinc_field_has_explicit_non_null_value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};// -------------------------------------------------------------------

class CreateTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spectrum.CreateTableRequest) */ {
 public:
  inline CreateTableRequest() : CreateTableRequest(nullptr) {}
  ~CreateTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateTableRequest(const CreateTableRequest& from)
      : CreateTableRequest(nullptr, from) {}
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateTableRequest& from) {
    CreateTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "spectrum.CreateTableRequest";
  }
  protected:
  explicit CreateTableRequest(::google::protobuf::Arena* arena);
  CreateTableRequest(::google::protobuf::Arena* arena, const CreateTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 2,
    kTableFieldNumber = 3,
    kThreadFieldNumber = 1,
  };
  // string database = 2;
  void clear_database() ;
  const std::string& database() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_database(Arg_&& arg, Args_... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* value);

  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(
      const std::string& value);
  std::string* _internal_mutable_database();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(
      const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // .spectrum.Thread thread = 1;
  bool has_thread() const;
  void clear_thread() ;
  const ::spectrum::Thread& thread() const;
  PROTOBUF_NODISCARD ::spectrum::Thread* release_thread();
  ::spectrum::Thread* mutable_thread();
  void set_allocated_thread(::spectrum::Thread* value);
  void unsafe_arena_set_allocated_thread(::spectrum::Thread* value);
  ::spectrum::Thread* unsafe_arena_release_thread();

  private:
  const ::spectrum::Thread& _internal_thread() const;
  ::spectrum::Thread* _internal_mutable_thread();

  public:
  // @@protoc_insertion_point(class_scope:spectrum.CreateTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr database_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    ::spectrum::Thread* thread_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spectrum_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Thread

// repeated .spectrum.MDL mdl_list = 1;
inline int Thread::_internal_mdl_list_size() const {
  return _internal_mdl_list().size();
}
inline int Thread::mdl_list_size() const {
  return _internal_mdl_list_size();
}
inline void Thread::clear_mdl_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mdl_list_.Clear();
}
inline ::spectrum::MDL* Thread::mutable_mdl_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:spectrum.Thread.mdl_list)
  return _internal_mutable_mdl_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::spectrum::MDL>* Thread::mutable_mdl_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:spectrum.Thread.mdl_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mdl_list();
}
inline const ::spectrum::MDL& Thread::mdl_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.Thread.mdl_list)
  return _internal_mdl_list().Get(index);
}
inline ::spectrum::MDL* Thread::add_mdl_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::spectrum::MDL* _add = _internal_mutable_mdl_list()->Add();
  // @@protoc_insertion_point(field_add:spectrum.Thread.mdl_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::spectrum::MDL>& Thread::mdl_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:spectrum.Thread.mdl_list)
  return _internal_mdl_list();
}
inline const ::google::protobuf::RepeatedPtrField<::spectrum::MDL>&
Thread::_internal_mdl_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mdl_list_;
}
inline ::google::protobuf::RepeatedPtrField<::spectrum::MDL>*
Thread::_internal_mutable_mdl_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mdl_list_;
}

// -------------------------------------------------------------------

// MDL

// int32 namespace = 1;
inline void MDL::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__ = 0;
}
inline ::int32_t MDL::namespace_() const {
  // @@protoc_insertion_point(field_get:spectrum.MDL.namespace)
  return _internal_namespace_();
}
inline void MDL::set_namespace_(::int32_t value) {
  _internal_set_namespace_(value);
  // @@protoc_insertion_point(field_set:spectrum.MDL.namespace)
}
inline ::int32_t MDL::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__;
}
inline void MDL::_internal_set_namespace_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__ = value;
}

// string schema = 2;
inline void MDL::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& MDL::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.MDL.schema)
  return _internal_schema();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MDL::set_schema(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.MDL.schema)
}
inline std::string* MDL::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:spectrum.MDL.schema)
  return _s;
}
inline const std::string& MDL::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_.Get();
}
inline void MDL::_internal_set_schema(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schema_.Set(value, GetArena());
}
inline std::string* MDL::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.schema_.Mutable( GetArena());
}
inline std::string* MDL::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.MDL.schema)
  return _impl_.schema_.Release();
}
inline void MDL::set_allocated_schema(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_.IsDefault()) {
          _impl_.schema_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.MDL.schema)
}

// string table = 3;
inline void MDL::clear_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.ClearToEmpty();
}
inline const std::string& MDL::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.MDL.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MDL::set_table(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.MDL.table)
}
inline std::string* MDL::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:spectrum.MDL.table)
  return _s;
}
inline const std::string& MDL::_internal_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.table_.Get();
}
inline void MDL::_internal_set_table(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* MDL::_internal_mutable_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* MDL::release_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.MDL.table)
  return _impl_.table_.Release();
}
inline void MDL::set_allocated_table(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_.IsDefault()) {
          _impl_.table_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.MDL.table)
}

// string column = 4;
inline void MDL::clear_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_.ClearToEmpty();
}
inline const std::string& MDL::column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.MDL.column)
  return _internal_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MDL::set_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.MDL.column)
}
inline std::string* MDL::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:spectrum.MDL.column)
  return _s;
}
inline const std::string& MDL::_internal_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_.Get();
}
inline void MDL::_internal_set_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_.Set(value, GetArena());
}
inline std::string* MDL::_internal_mutable_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_.Mutable( GetArena());
}
inline std::string* MDL::release_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.MDL.column)
  return _impl_.column_.Release();
}
inline void MDL::set_allocated_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_.IsDefault()) {
          _impl_.column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.MDL.column)
}

// int32 type = 5;
inline void MDL::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::int32_t MDL::type() const {
  // @@protoc_insertion_point(field_get:spectrum.MDL.type)
  return _internal_type();
}
inline void MDL::set_type(::int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:spectrum.MDL.type)
}
inline ::int32_t MDL::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void MDL::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// Row

// repeated .spectrum.Field fields = 3;
inline int Row::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int Row::fields_size() const {
  return _internal_fields_size();
}
inline void Row::clear_fields() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fields_.Clear();
}
inline ::spectrum::Field* Row::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:spectrum.Row.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::spectrum::Field>* Row::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:spectrum.Row.fields)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fields();
}
inline const ::spectrum::Field& Row::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.Row.fields)
  return _internal_fields().Get(index);
}
inline ::spectrum::Field* Row::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::spectrum::Field* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:spectrum.Row.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::spectrum::Field>& Row::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:spectrum.Row.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::spectrum::Field>&
Row::_internal_fields() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::spectrum::Field>*
Row::_internal_mutable_fields() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// Field

// string name = 1;
inline void Field::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Field::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.Field.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Field::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.Field.name)
}
inline std::string* Field::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spectrum.Field.name)
  return _s;
}
inline const std::string& Field::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Field::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Field::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Field::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.Field.name)
  return _impl_.name_.Release();
}
inline void Field::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.Field.name)
}

// bytes value = 2;
inline void Field::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Field::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.Field.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Field::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.Field.value)
}
inline std::string* Field::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:spectrum.Field.value)
  return _s;
}
inline const std::string& Field::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void Field::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Field::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Field::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.Field.value)
  return _impl_.value_.Release();
}
inline void Field::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.Field.value)
}

// bool is_null = 3;
inline void Field::clear_is_null() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_null_ = false;
}
inline bool Field::is_null() const {
  // @@protoc_insertion_point(field_get:spectrum.Field.is_null)
  return _internal_is_null();
}
inline void Field::set_is_null(bool value) {
  _internal_set_is_null(value);
  // @@protoc_insertion_point(field_set:spectrum.Field.is_null)
}
inline bool Field::_internal_is_null() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_null_;
}
inline void Field::_internal_set_is_null(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_null_ = value;
}

// -------------------------------------------------------------------

// CreateTableRequest

// .spectrum.Thread thread = 1;
inline bool CreateTableRequest::has_thread() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.thread_ != nullptr);
  return value;
}
inline void CreateTableRequest::clear_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.thread_ != nullptr) _impl_.thread_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::Thread& CreateTableRequest::_internal_thread() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::Thread* p = _impl_.thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::Thread&>(::spectrum::_Thread_default_instance_);
}
inline const ::spectrum::Thread& CreateTableRequest::thread() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.CreateTableRequest.thread)
  return _internal_thread();
}
inline void CreateTableRequest::unsafe_arena_set_allocated_thread(::spectrum::Thread* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.thread_);
  }
  _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.CreateTableRequest.thread)
}
inline ::spectrum::Thread* CreateTableRequest::release_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Thread* released = _impl_.thread_;
  _impl_.thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::Thread* CreateTableRequest::unsafe_arena_release_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.CreateTableRequest.thread)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Thread* temp = _impl_.thread_;
  _impl_.thread_ = nullptr;
  return temp;
}
inline ::spectrum::Thread* CreateTableRequest::_internal_mutable_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::Thread>(GetArena());
    _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(p);
  }
  return _impl_.thread_;
}
inline ::spectrum::Thread* CreateTableRequest::mutable_thread() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::Thread* _msg = _internal_mutable_thread();
  // @@protoc_insertion_point(field_mutable:spectrum.CreateTableRequest.thread)
  return _msg;
}
inline void CreateTableRequest::set_allocated_thread(::spectrum::Thread* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::Thread*>(_impl_.thread_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::Thread*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.CreateTableRequest.thread)
}

// string database = 2;
inline void CreateTableRequest::clear_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::database() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.CreateTableRequest.database)
  return _internal_database();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTableRequest::set_database(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.CreateTableRequest.database)
}
inline std::string* CreateTableRequest::mutable_database() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:spectrum.CreateTableRequest.database)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_database() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.database_.Get();
}
inline void CreateTableRequest::_internal_set_database(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(value, GetArena());
}
inline std::string* CreateTableRequest::_internal_mutable_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.database_.Mutable( GetArena());
}
inline std::string* CreateTableRequest::release_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.CreateTableRequest.database)
  return _impl_.database_.Release();
}
inline void CreateTableRequest::set_allocated_database(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.database_.IsDefault()) {
          _impl_.database_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.CreateTableRequest.database)
}

// string table = 3;
inline void CreateTableRequest::clear_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.CreateTableRequest.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTableRequest::set_table(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.CreateTableRequest.table)
}
inline std::string* CreateTableRequest::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:spectrum.CreateTableRequest.table)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.table_.Get();
}
inline void CreateTableRequest::_internal_set_table(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* CreateTableRequest::_internal_mutable_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* CreateTableRequest::release_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.CreateTableRequest.table)
  return _impl_.table_.Release();
}
inline void CreateTableRequest::set_allocated_table(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_.IsDefault()) {
          _impl_.table_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.CreateTableRequest.table)
}

// -------------------------------------------------------------------

// CreateTableResponse

// -------------------------------------------------------------------

// WriteRowRequest

// .spectrum.Thread thread = 1;
inline bool WriteRowRequest::has_thread() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.thread_ != nullptr);
  return value;
}
inline void WriteRowRequest::clear_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.thread_ != nullptr) _impl_.thread_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::Thread& WriteRowRequest::_internal_thread() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::Thread* p = _impl_.thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::Thread&>(::spectrum::_Thread_default_instance_);
}
inline const ::spectrum::Thread& WriteRowRequest::thread() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowRequest.thread)
  return _internal_thread();
}
inline void WriteRowRequest::unsafe_arena_set_allocated_thread(::spectrum::Thread* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.thread_);
  }
  _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.WriteRowRequest.thread)
}
inline ::spectrum::Thread* WriteRowRequest::release_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Thread* released = _impl_.thread_;
  _impl_.thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::Thread* WriteRowRequest::unsafe_arena_release_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.WriteRowRequest.thread)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Thread* temp = _impl_.thread_;
  _impl_.thread_ = nullptr;
  return temp;
}
inline ::spectrum::Thread* WriteRowRequest::_internal_mutable_thread() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::Thread>(GetArena());
    _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(p);
  }
  return _impl_.thread_;
}
inline ::spectrum::Thread* WriteRowRequest::mutable_thread() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::Thread* _msg = _internal_mutable_thread();
  // @@protoc_insertion_point(field_mutable:spectrum.WriteRowRequest.thread)
  return _msg;
}
inline void WriteRowRequest::set_allocated_thread(::spectrum::Thread* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::Thread*>(_impl_.thread_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::Thread*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.thread_ = reinterpret_cast<::spectrum::Thread*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.WriteRowRequest.thread)
}

// string database = 2;
inline void WriteRowRequest::clear_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.ClearToEmpty();
}
inline const std::string& WriteRowRequest::database() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowRequest.database)
  return _internal_database();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WriteRowRequest::set_database(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.WriteRowRequest.database)
}
inline std::string* WriteRowRequest::mutable_database() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:spectrum.WriteRowRequest.database)
  return _s;
}
inline const std::string& WriteRowRequest::_internal_database() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.database_.Get();
}
inline void WriteRowRequest::_internal_set_database(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(value, GetArena());
}
inline std::string* WriteRowRequest::_internal_mutable_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.database_.Mutable( GetArena());
}
inline std::string* WriteRowRequest::release_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.WriteRowRequest.database)
  return _impl_.database_.Release();
}
inline void WriteRowRequest::set_allocated_database(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.database_.IsDefault()) {
          _impl_.database_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.WriteRowRequest.database)
}

// string table = 3;
inline void WriteRowRequest::clear_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.ClearToEmpty();
}
inline const std::string& WriteRowRequest::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowRequest.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WriteRowRequest::set_table(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.WriteRowRequest.table)
}
inline std::string* WriteRowRequest::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:spectrum.WriteRowRequest.table)
  return _s;
}
inline const std::string& WriteRowRequest::_internal_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.table_.Get();
}
inline void WriteRowRequest::_internal_set_table(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* WriteRowRequest::_internal_mutable_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* WriteRowRequest::release_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.WriteRowRequest.table)
  return _impl_.table_.Release();
}
inline void WriteRowRequest::set_allocated_table(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_.IsDefault()) {
          _impl_.table_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.WriteRowRequest.table)
}

// .spectrum.Row row = 4;
inline bool WriteRowRequest::has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row_ != nullptr);
  return value;
}
inline void WriteRowRequest::clear_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.row_ != nullptr) _impl_.row_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spectrum::Row& WriteRowRequest::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::Row* p = _impl_.row_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::Row&>(::spectrum::_Row_default_instance_);
}
inline const ::spectrum::Row& WriteRowRequest::row() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowRequest.row)
  return _internal_row();
}
inline void WriteRowRequest::unsafe_arena_set_allocated_row(::spectrum::Row* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row_);
  }
  _impl_.row_ = reinterpret_cast<::spectrum::Row*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.WriteRowRequest.row)
}
inline ::spectrum::Row* WriteRowRequest::release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::Row* released = _impl_.row_;
  _impl_.row_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::Row* WriteRowRequest::unsafe_arena_release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.WriteRowRequest.row)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::Row* temp = _impl_.row_;
  _impl_.row_ = nullptr;
  return temp;
}
inline ::spectrum::Row* WriteRowRequest::_internal_mutable_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.row_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::Row>(GetArena());
    _impl_.row_ = reinterpret_cast<::spectrum::Row*>(p);
  }
  return _impl_.row_;
}
inline ::spectrum::Row* WriteRowRequest::mutable_row() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::Row* _msg = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:spectrum.WriteRowRequest.row)
  return _msg;
}
inline void WriteRowRequest::set_allocated_row(::spectrum::Row* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::Row*>(_impl_.row_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::Row*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.row_ = reinterpret_cast<::spectrum::Row*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.WriteRowRequest.row)
}

// bool autoinc_field_has_explicit_non_null_value = 5;
inline void WriteRowRequest::clear_autoinc_field_has_explicit_non_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.autoinc_field_has_explicit_non_null_value_ = false;
}
inline bool WriteRowRequest::autoinc_field_has_explicit_non_null_value() const {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowRequest.autoinc_field_has_explicit_non_null_value)
  return _internal_autoinc_field_has_explicit_non_null_value();
}
inline void WriteRowRequest::set_autoinc_field_has_explicit_non_null_value(bool value) {
  _internal_set_autoinc_field_has_explicit_non_null_value(value);
  // @@protoc_insertion_point(field_set:spectrum.WriteRowRequest.autoinc_field_has_explicit_non_null_value)
}
inline bool WriteRowRequest::_internal_autoinc_field_has_explicit_non_null_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.autoinc_field_has_explicit_non_null_value_;
}
inline void WriteRowRequest::_internal_set_autoinc_field_has_explicit_non_null_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.autoinc_field_has_explicit_non_null_value_ = value;
}

// -------------------------------------------------------------------

// WriteRowResponse

// int64 insert_id = 1;
inline void WriteRowResponse::clear_insert_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.insert_id_ = ::int64_t{0};
}
inline ::int64_t WriteRowResponse::insert_id() const {
  // @@protoc_insertion_point(field_get:spectrum.WriteRowResponse.insert_id)
  return _internal_insert_id();
}
inline void WriteRowResponse::set_insert_id(::int64_t value) {
  _internal_set_insert_id(value);
  // @@protoc_insertion_point(field_set:spectrum.WriteRowResponse.insert_id)
}
inline ::int64_t WriteRowResponse::_internal_insert_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.insert_id_;
}
inline void WriteRowResponse::_internal_set_insert_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.insert_id_ = value;
}

// -------------------------------------------------------------------

// UpdateRowRequest

// string database = 1;
inline void UpdateRowRequest::clear_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.ClearToEmpty();
}
inline const std::string& UpdateRowRequest::database() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.UpdateRowRequest.database)
  return _internal_database();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateRowRequest::set_database(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.UpdateRowRequest.database)
}
inline std::string* UpdateRowRequest::mutable_database() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:spectrum.UpdateRowRequest.database)
  return _s;
}
inline const std::string& UpdateRowRequest::_internal_database() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.database_.Get();
}
inline void UpdateRowRequest::_internal_set_database(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.database_.Set(value, GetArena());
}
inline std::string* UpdateRowRequest::_internal_mutable_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.database_.Mutable( GetArena());
}
inline std::string* UpdateRowRequest::release_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.UpdateRowRequest.database)
  return _impl_.database_.Release();
}
inline void UpdateRowRequest::set_allocated_database(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.database_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.database_.IsDefault()) {
          _impl_.database_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.UpdateRowRequest.database)
}

// string table = 2;
inline void UpdateRowRequest::clear_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.ClearToEmpty();
}
inline const std::string& UpdateRowRequest::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.UpdateRowRequest.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateRowRequest::set_table(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.UpdateRowRequest.table)
}
inline std::string* UpdateRowRequest::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:spectrum.UpdateRowRequest.table)
  return _s;
}
inline const std::string& UpdateRowRequest::_internal_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.table_.Get();
}
inline void UpdateRowRequest::_internal_set_table(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* UpdateRowRequest::_internal_mutable_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* UpdateRowRequest::release_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.UpdateRowRequest.table)
  return _impl_.table_.Release();
}
inline void UpdateRowRequest::set_allocated_table(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_.IsDefault()) {
          _impl_.table_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.UpdateRowRequest.table)
}

// .spectrum.Row row = 3;
inline bool UpdateRowRequest::has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row_ != nullptr);
  return value;
}
inline void UpdateRowRequest::clear_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.row_ != nullptr) _impl_.row_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::Row& UpdateRowRequest::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::Row* p = _impl_.row_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::Row&>(::spectrum::_Row_default_instance_);
}
inline const ::spectrum::Row& UpdateRowRequest::row() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.UpdateRowRequest.row)
  return _internal_row();
}
inline void UpdateRowRequest::unsafe_arena_set_allocated_row(::spectrum::Row* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row_);
  }
  _impl_.row_ = reinterpret_cast<::spectrum::Row*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.UpdateRowRequest.row)
}
inline ::spectrum::Row* UpdateRowRequest::release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Row* released = _impl_.row_;
  _impl_.row_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::Row* UpdateRowRequest::unsafe_arena_release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.UpdateRowRequest.row)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::Row* temp = _impl_.row_;
  _impl_.row_ = nullptr;
  return temp;
}
inline ::spectrum::Row* UpdateRowRequest::_internal_mutable_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.row_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::Row>(GetArena());
    _impl_.row_ = reinterpret_cast<::spectrum::Row*>(p);
  }
  return _impl_.row_;
}
inline ::spectrum::Row* UpdateRowRequest::mutable_row() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::Row* _msg = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:spectrum.UpdateRowRequest.row)
  return _msg;
}
inline void UpdateRowRequest::set_allocated_row(::spectrum::Row* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::Row*>(_impl_.row_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::Row*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.row_ = reinterpret_cast<::spectrum::Row*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.UpdateRowRequest.row)
}

// bool autoinc_field_has_explicit_non_null_value = 4;
inline void UpdateRowRequest::clear_autoinc_field_has_explicit_non_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.autoinc_field_has_explicit_non_null_value_ = false;
}
inline bool UpdateRowRequest::autoinc_field_has_explicit_non_null_value() const {
  // @@protoc_insertion_point(field_get:spectrum.UpdateRowRequest.autoinc_field_has_explicit_non_null_value)
  return _internal_autoinc_field_has_explicit_non_null_value();
}
inline void UpdateRowRequest::set_autoinc_field_has_explicit_non_null_value(bool value) {
  _internal_set_autoinc_field_has_explicit_non_null_value(value);
  // @@protoc_insertion_point(field_set:spectrum.UpdateRowRequest.autoinc_field_has_explicit_non_null_value)
}
inline bool UpdateRowRequest::_internal_autoinc_field_has_explicit_non_null_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.autoinc_field_has_explicit_non_null_value_;
}
inline void UpdateRowRequest::_internal_set_autoinc_field_has_explicit_non_null_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.autoinc_field_has_explicit_non_null_value_ = value;
}

// -------------------------------------------------------------------

// UpdateRowResponse

// -------------------------------------------------------------------

// CreateReplicaRequestMessage

// string namespace = 1;
inline void CreateReplicaRequestMessage::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& CreateReplicaRequestMessage::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.CreateReplicaRequestMessage.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateReplicaRequestMessage::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.CreateReplicaRequestMessage.namespace)
}
inline std::string* CreateReplicaRequestMessage::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:spectrum.CreateReplicaRequestMessage.namespace)
  return _s;
}
inline const std::string& CreateReplicaRequestMessage::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void CreateReplicaRequestMessage::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* CreateReplicaRequestMessage::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* CreateReplicaRequestMessage::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.CreateReplicaRequestMessage.namespace)
  return _impl_.namespace__.Release();
}
inline void CreateReplicaRequestMessage::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.CreateReplicaRequestMessage.namespace)
}

// int32 replicaId = 2;
inline void CreateReplicaRequestMessage::clear_replicaid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replicaid_ = 0;
}
inline ::int32_t CreateReplicaRequestMessage::replicaid() const {
  // @@protoc_insertion_point(field_get:spectrum.CreateReplicaRequestMessage.replicaId)
  return _internal_replicaid();
}
inline void CreateReplicaRequestMessage::set_replicaid(::int32_t value) {
  _internal_set_replicaid(value);
  // @@protoc_insertion_point(field_set:spectrum.CreateReplicaRequestMessage.replicaId)
}
inline ::int32_t CreateReplicaRequestMessage::_internal_replicaid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replicaid_;
}
inline void CreateReplicaRequestMessage::_internal_set_replicaid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.replicaid_ = value;
}

// -------------------------------------------------------------------

// CreateReplicaResponseMessage

// string acceptorId = 1;
inline void CreateReplicaResponseMessage::clear_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.ClearToEmpty();
}
inline const std::string& CreateReplicaResponseMessage::acceptorid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.CreateReplicaResponseMessage.acceptorId)
  return _internal_acceptorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateReplicaResponseMessage::set_acceptorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.CreateReplicaResponseMessage.acceptorId)
}
inline std::string* CreateReplicaResponseMessage::mutable_acceptorid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acceptorid();
  // @@protoc_insertion_point(field_mutable:spectrum.CreateReplicaResponseMessage.acceptorId)
  return _s;
}
inline const std::string& CreateReplicaResponseMessage::_internal_acceptorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptorid_.Get();
}
inline void CreateReplicaResponseMessage::_internal_set_acceptorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(value, GetArena());
}
inline std::string* CreateReplicaResponseMessage::_internal_mutable_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.acceptorid_.Mutable( GetArena());
}
inline std::string* CreateReplicaResponseMessage::release_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.CreateReplicaResponseMessage.acceptorId)
  return _impl_.acceptorid_.Release();
}
inline void CreateReplicaResponseMessage::set_allocated_acceptorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acceptorid_.IsDefault()) {
          _impl_.acceptorid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.CreateReplicaResponseMessage.acceptorId)
}

// -------------------------------------------------------------------

// UpdateEpochRequestMessage

// string namespace = 1;
inline void UpdateEpochRequestMessage::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& UpdateEpochRequestMessage::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.UpdateEpochRequestMessage.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateEpochRequestMessage::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.UpdateEpochRequestMessage.namespace)
}
inline std::string* UpdateEpochRequestMessage::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:spectrum.UpdateEpochRequestMessage.namespace)
  return _s;
}
inline const std::string& UpdateEpochRequestMessage::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void UpdateEpochRequestMessage::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* UpdateEpochRequestMessage::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* UpdateEpochRequestMessage::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.UpdateEpochRequestMessage.namespace)
  return _impl_.namespace__.Release();
}
inline void UpdateEpochRequestMessage::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.UpdateEpochRequestMessage.namespace)
}

// int32 replicaId = 2;
inline void UpdateEpochRequestMessage::clear_replicaid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replicaid_ = 0;
}
inline ::int32_t UpdateEpochRequestMessage::replicaid() const {
  // @@protoc_insertion_point(field_get:spectrum.UpdateEpochRequestMessage.replicaId)
  return _internal_replicaid();
}
inline void UpdateEpochRequestMessage::set_replicaid(::int32_t value) {
  _internal_set_replicaid(value);
  // @@protoc_insertion_point(field_set:spectrum.UpdateEpochRequestMessage.replicaId)
}
inline ::int32_t UpdateEpochRequestMessage::_internal_replicaid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replicaid_;
}
inline void UpdateEpochRequestMessage::_internal_set_replicaid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.replicaid_ = value;
}

// int64 epoch = 3;
inline void UpdateEpochRequestMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t UpdateEpochRequestMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.UpdateEpochRequestMessage.epoch)
  return _internal_epoch();
}
inline void UpdateEpochRequestMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.UpdateEpochRequestMessage.epoch)
}
inline ::int64_t UpdateEpochRequestMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void UpdateEpochRequestMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// -------------------------------------------------------------------

// UpdateEpochResponseMessage

// int64 epoch = 1;
inline void UpdateEpochResponseMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t UpdateEpochResponseMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.UpdateEpochResponseMessage.epoch)
  return _internal_epoch();
}
inline void UpdateEpochResponseMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.UpdateEpochResponseMessage.epoch)
}
inline ::int64_t UpdateEpochResponseMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void UpdateEpochResponseMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// -------------------------------------------------------------------

// DataItemMessage

// string namespace = 1;
inline void DataItemMessage::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& DataItemMessage::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.DataItemMessage.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataItemMessage::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.DataItemMessage.namespace)
}
inline std::string* DataItemMessage::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:spectrum.DataItemMessage.namespace)
  return _s;
}
inline const std::string& DataItemMessage::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void DataItemMessage::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* DataItemMessage::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* DataItemMessage::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.DataItemMessage.namespace)
  return _impl_.namespace__.Release();
}
inline void DataItemMessage::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.DataItemMessage.namespace)
}

// string key = 2;
inline void DataItemMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DataItemMessage::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.DataItemMessage.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataItemMessage::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.DataItemMessage.key)
}
inline std::string* DataItemMessage::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spectrum.DataItemMessage.key)
  return _s;
}
inline const std::string& DataItemMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void DataItemMessage::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* DataItemMessage::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* DataItemMessage::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.DataItemMessage.key)
  return _impl_.key_.Release();
}
inline void DataItemMessage::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.DataItemMessage.key)
}

// optional string value = 3;
inline bool DataItemMessage::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DataItemMessage::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataItemMessage::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.DataItemMessage.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataItemMessage::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.DataItemMessage.value)
}
inline std::string* DataItemMessage::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:spectrum.DataItemMessage.value)
  return _s;
}
inline const std::string& DataItemMessage::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void DataItemMessage::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* DataItemMessage::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* DataItemMessage::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.DataItemMessage.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataItemMessage::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.DataItemMessage.value)
}

// optional bool isNext = 4;
inline bool DataItemMessage::has_isnext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DataItemMessage::clear_isnext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isnext_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DataItemMessage::isnext() const {
  // @@protoc_insertion_point(field_get:spectrum.DataItemMessage.isNext)
  return _internal_isnext();
}
inline void DataItemMessage::set_isnext(bool value) {
  _internal_set_isnext(value);
  // @@protoc_insertion_point(field_set:spectrum.DataItemMessage.isNext)
}
inline bool DataItemMessage::_internal_isnext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isnext_;
}
inline void DataItemMessage::_internal_set_isnext(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.isnext_ = value;
}

// int64 version = 5;
inline void DataItemMessage::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = ::int64_t{0};
}
inline ::int64_t DataItemMessage::version() const {
  // @@protoc_insertion_point(field_get:spectrum.DataItemMessage.version)
  return _internal_version();
}
inline void DataItemMessage::set_version(::int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:spectrum.DataItemMessage.version)
}
inline ::int64_t DataItemMessage::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void DataItemMessage::_internal_set_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// ProposalMessage

// string key = 1;
inline void ProposalMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProposalMessage::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProposalMessage::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.ProposalMessage.key)
}
inline std::string* ProposalMessage::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spectrum.ProposalMessage.key)
  return _s;
}
inline const std::string& ProposalMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void ProposalMessage::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* ProposalMessage::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* ProposalMessage::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.ProposalMessage.key)
  return _impl_.key_.Release();
}
inline void ProposalMessage::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.ProposalMessage.key)
}

// optional string value = 2;
inline bool ProposalMessage::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProposalMessage::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProposalMessage::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProposalMessage::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.ProposalMessage.value)
}
inline std::string* ProposalMessage::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:spectrum.ProposalMessage.value)
  return _s;
}
inline const std::string& ProposalMessage::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void ProposalMessage::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* ProposalMessage::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* ProposalMessage::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.ProposalMessage.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProposalMessage::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.ProposalMessage.value)
}

// optional bool isNext = 3;
inline bool ProposalMessage::has_isnext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ProposalMessage::clear_isnext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isnext_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ProposalMessage::isnext() const {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.isNext)
  return _internal_isnext();
}
inline void ProposalMessage::set_isnext(bool value) {
  _internal_set_isnext(value);
  // @@protoc_insertion_point(field_set:spectrum.ProposalMessage.isNext)
}
inline bool ProposalMessage::_internal_isnext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isnext_;
}
inline void ProposalMessage::_internal_set_isnext(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.isnext_ = value;
}

// int64 version = 4;
inline void ProposalMessage::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = ::int64_t{0};
}
inline ::int64_t ProposalMessage::version() const {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.version)
  return _internal_version();
}
inline void ProposalMessage::set_version(::int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:spectrum.ProposalMessage.version)
}
inline ::int64_t ProposalMessage::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void ProposalMessage::_internal_set_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// int64 sequenceNumber = 5;
inline void ProposalMessage::clear_sequencenumber() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequencenumber_ = ::int64_t{0};
}
inline ::int64_t ProposalMessage::sequencenumber() const {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.sequenceNumber)
  return _internal_sequencenumber();
}
inline void ProposalMessage::set_sequencenumber(::int64_t value) {
  _internal_set_sequencenumber(value);
  // @@protoc_insertion_point(field_set:spectrum.ProposalMessage.sequenceNumber)
}
inline ::int64_t ProposalMessage::_internal_sequencenumber() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequencenumber_;
}
inline void ProposalMessage::_internal_set_sequencenumber(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sequencenumber_ = value;
}

// optional .spectrum.ProposalMessage parentProposal = 6;
inline bool ProposalMessage::has_parentproposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parentproposal_ != nullptr);
  return value;
}
inline void ProposalMessage::clear_parentproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.parentproposal_ != nullptr) _impl_.parentproposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spectrum::ProposalMessage& ProposalMessage::_internal_parentproposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.parentproposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& ProposalMessage::parentproposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.ProposalMessage.parentProposal)
  return _internal_parentproposal();
}
inline void ProposalMessage::unsafe_arena_set_allocated_parentproposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parentproposal_);
  }
  _impl_.parentproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.ProposalMessage.parentProposal)
}
inline ::spectrum::ProposalMessage* ProposalMessage::release_parentproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* released = _impl_.parentproposal_;
  _impl_.parentproposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* ProposalMessage::unsafe_arena_release_parentproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.ProposalMessage.parentProposal)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* temp = _impl_.parentproposal_;
  _impl_.parentproposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* ProposalMessage::_internal_mutable_parentproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.parentproposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.parentproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.parentproposal_;
}
inline ::spectrum::ProposalMessage* ProposalMessage::mutable_parentproposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_parentproposal();
  // @@protoc_insertion_point(field_mutable:spectrum.ProposalMessage.parentProposal)
  return _msg;
}
inline void ProposalMessage::set_allocated_parentproposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.parentproposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parentproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.ProposalMessage.parentProposal)
}

// -------------------------------------------------------------------

// PrepareRequestMessage

// string acceptorId = 1;
inline void PrepareRequestMessage::clear_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.ClearToEmpty();
}
inline const std::string& PrepareRequestMessage::acceptorid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.PrepareRequestMessage.acceptorId)
  return _internal_acceptorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareRequestMessage::set_acceptorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.PrepareRequestMessage.acceptorId)
}
inline std::string* PrepareRequestMessage::mutable_acceptorid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acceptorid();
  // @@protoc_insertion_point(field_mutable:spectrum.PrepareRequestMessage.acceptorId)
  return _s;
}
inline const std::string& PrepareRequestMessage::_internal_acceptorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptorid_.Get();
}
inline void PrepareRequestMessage::_internal_set_acceptorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(value, GetArena());
}
inline std::string* PrepareRequestMessage::_internal_mutable_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.acceptorid_.Mutable( GetArena());
}
inline std::string* PrepareRequestMessage::release_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.PrepareRequestMessage.acceptorId)
  return _impl_.acceptorid_.Release();
}
inline void PrepareRequestMessage::set_allocated_acceptorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acceptorid_.IsDefault()) {
          _impl_.acceptorid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.PrepareRequestMessage.acceptorId)
}

// int64 epoch = 2;
inline void PrepareRequestMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t PrepareRequestMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.PrepareRequestMessage.epoch)
  return _internal_epoch();
}
inline void PrepareRequestMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.PrepareRequestMessage.epoch)
}
inline ::int64_t PrepareRequestMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void PrepareRequestMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// .spectrum.ProposalMessage proposal = 3;
inline bool PrepareRequestMessage::has_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposal_ != nullptr);
  return value;
}
inline void PrepareRequestMessage::clear_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.proposal_ != nullptr) _impl_.proposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::ProposalMessage& PrepareRequestMessage::_internal_proposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& PrepareRequestMessage::proposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.PrepareRequestMessage.proposal)
  return _internal_proposal();
}
inline void PrepareRequestMessage::unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proposal_);
  }
  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.PrepareRequestMessage.proposal)
}
inline ::spectrum::ProposalMessage* PrepareRequestMessage::release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* released = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* PrepareRequestMessage::unsafe_arena_release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.PrepareRequestMessage.proposal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* PrepareRequestMessage::_internal_mutable_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.proposal_;
}
inline ::spectrum::ProposalMessage* PrepareRequestMessage::mutable_proposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:spectrum.PrepareRequestMessage.proposal)
  return _msg;
}
inline void PrepareRequestMessage::set_allocated_proposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.proposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.PrepareRequestMessage.proposal)
}

// -------------------------------------------------------------------

// PrepareResponseMessage

// bool prepared = 1;
inline void PrepareResponseMessage::clear_prepared() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prepared_ = false;
}
inline bool PrepareResponseMessage::prepared() const {
  // @@protoc_insertion_point(field_get:spectrum.PrepareResponseMessage.prepared)
  return _internal_prepared();
}
inline void PrepareResponseMessage::set_prepared(bool value) {
  _internal_set_prepared(value);
  // @@protoc_insertion_point(field_set:spectrum.PrepareResponseMessage.prepared)
}
inline bool PrepareResponseMessage::_internal_prepared() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prepared_;
}
inline void PrepareResponseMessage::_internal_set_prepared(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prepared_ = value;
}

// .spectrum.ProposalMessage preparedProposal = 2;
inline bool PrepareResponseMessage::has_preparedproposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.preparedproposal_ != nullptr);
  return value;
}
inline void PrepareResponseMessage::clear_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.preparedproposal_ != nullptr) _impl_.preparedproposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::ProposalMessage& PrepareResponseMessage::_internal_preparedproposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.preparedproposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& PrepareResponseMessage::preparedproposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.PrepareResponseMessage.preparedProposal)
  return _internal_preparedproposal();
}
inline void PrepareResponseMessage::unsafe_arena_set_allocated_preparedproposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.preparedproposal_);
  }
  _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.PrepareResponseMessage.preparedProposal)
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::release_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* released = _impl_.preparedproposal_;
  _impl_.preparedproposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::unsafe_arena_release_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.PrepareResponseMessage.preparedProposal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* temp = _impl_.preparedproposal_;
  _impl_.preparedproposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::_internal_mutable_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.preparedproposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.preparedproposal_;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::mutable_preparedproposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_preparedproposal();
  // @@protoc_insertion_point(field_mutable:spectrum.PrepareResponseMessage.preparedProposal)
  return _msg;
}
inline void PrepareResponseMessage::set_allocated_preparedproposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.preparedproposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.PrepareResponseMessage.preparedProposal)
}

// .spectrum.ProposalMessage acceptedProposal = 3;
inline bool PrepareResponseMessage::has_acceptedproposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceptedproposal_ != nullptr);
  return value;
}
inline void PrepareResponseMessage::clear_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.acceptedproposal_ != nullptr) _impl_.acceptedproposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spectrum::ProposalMessage& PrepareResponseMessage::_internal_acceptedproposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.acceptedproposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& PrepareResponseMessage::acceptedproposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.PrepareResponseMessage.acceptedProposal)
  return _internal_acceptedproposal();
}
inline void PrepareResponseMessage::unsafe_arena_set_allocated_acceptedproposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceptedproposal_);
  }
  _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.PrepareResponseMessage.acceptedProposal)
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::release_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* released = _impl_.acceptedproposal_;
  _impl_.acceptedproposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::unsafe_arena_release_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.PrepareResponseMessage.acceptedProposal)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* temp = _impl_.acceptedproposal_;
  _impl_.acceptedproposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::_internal_mutable_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.acceptedproposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.acceptedproposal_;
}
inline ::spectrum::ProposalMessage* PrepareResponseMessage::mutable_acceptedproposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_acceptedproposal();
  // @@protoc_insertion_point(field_mutable:spectrum.PrepareResponseMessage.acceptedProposal)
  return _msg;
}
inline void PrepareResponseMessage::set_allocated_acceptedproposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.acceptedproposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.PrepareResponseMessage.acceptedProposal)
}

// int64 epoch = 4;
inline void PrepareResponseMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t PrepareResponseMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.PrepareResponseMessage.epoch)
  return _internal_epoch();
}
inline void PrepareResponseMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.PrepareResponseMessage.epoch)
}
inline ::int64_t PrepareResponseMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void PrepareResponseMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// int64 maxSequenceNumber = 5;
inline void PrepareResponseMessage::clear_maxsequencenumber() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxsequencenumber_ = ::int64_t{0};
}
inline ::int64_t PrepareResponseMessage::maxsequencenumber() const {
  // @@protoc_insertion_point(field_get:spectrum.PrepareResponseMessage.maxSequenceNumber)
  return _internal_maxsequencenumber();
}
inline void PrepareResponseMessage::set_maxsequencenumber(::int64_t value) {
  _internal_set_maxsequencenumber(value);
  // @@protoc_insertion_point(field_set:spectrum.PrepareResponseMessage.maxSequenceNumber)
}
inline ::int64_t PrepareResponseMessage::_internal_maxsequencenumber() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxsequencenumber_;
}
inline void PrepareResponseMessage::_internal_set_maxsequencenumber(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.maxsequencenumber_ = value;
}

// -------------------------------------------------------------------

// AcceptRequestMessage

// string acceptorId = 1;
inline void AcceptRequestMessage::clear_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.ClearToEmpty();
}
inline const std::string& AcceptRequestMessage::acceptorid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AcceptRequestMessage.acceptorId)
  return _internal_acceptorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AcceptRequestMessage::set_acceptorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.AcceptRequestMessage.acceptorId)
}
inline std::string* AcceptRequestMessage::mutable_acceptorid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acceptorid();
  // @@protoc_insertion_point(field_mutable:spectrum.AcceptRequestMessage.acceptorId)
  return _s;
}
inline const std::string& AcceptRequestMessage::_internal_acceptorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptorid_.Get();
}
inline void AcceptRequestMessage::_internal_set_acceptorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(value, GetArena());
}
inline std::string* AcceptRequestMessage::_internal_mutable_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.acceptorid_.Mutable( GetArena());
}
inline std::string* AcceptRequestMessage::release_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AcceptRequestMessage.acceptorId)
  return _impl_.acceptorid_.Release();
}
inline void AcceptRequestMessage::set_allocated_acceptorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acceptorid_.IsDefault()) {
          _impl_.acceptorid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.AcceptRequestMessage.acceptorId)
}

// int64 epoch = 2;
inline void AcceptRequestMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t AcceptRequestMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.AcceptRequestMessage.epoch)
  return _internal_epoch();
}
inline void AcceptRequestMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.AcceptRequestMessage.epoch)
}
inline ::int64_t AcceptRequestMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void AcceptRequestMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// .spectrum.ProposalMessage proposal = 3;
inline bool AcceptRequestMessage::has_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposal_ != nullptr);
  return value;
}
inline void AcceptRequestMessage::clear_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.proposal_ != nullptr) _impl_.proposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::ProposalMessage& AcceptRequestMessage::_internal_proposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& AcceptRequestMessage::proposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AcceptRequestMessage.proposal)
  return _internal_proposal();
}
inline void AcceptRequestMessage::unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proposal_);
  }
  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.AcceptRequestMessage.proposal)
}
inline ::spectrum::ProposalMessage* AcceptRequestMessage::release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* released = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* AcceptRequestMessage::unsafe_arena_release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AcceptRequestMessage.proposal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* AcceptRequestMessage::_internal_mutable_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.proposal_;
}
inline ::spectrum::ProposalMessage* AcceptRequestMessage::mutable_proposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:spectrum.AcceptRequestMessage.proposal)
  return _msg;
}
inline void AcceptRequestMessage::set_allocated_proposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.proposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.AcceptRequestMessage.proposal)
}

// -------------------------------------------------------------------

// AcceptResponseMessage

// bool accepted = 1;
inline void AcceptResponseMessage::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool AcceptResponseMessage::accepted() const {
  // @@protoc_insertion_point(field_get:spectrum.AcceptResponseMessage.accepted)
  return _internal_accepted();
}
inline void AcceptResponseMessage::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:spectrum.AcceptResponseMessage.accepted)
}
inline bool AcceptResponseMessage::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void AcceptResponseMessage::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// .spectrum.ProposalMessage preparedProposal = 2;
inline bool AcceptResponseMessage::has_preparedproposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.preparedproposal_ != nullptr);
  return value;
}
inline void AcceptResponseMessage::clear_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.preparedproposal_ != nullptr) _impl_.preparedproposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::ProposalMessage& AcceptResponseMessage::_internal_preparedproposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.preparedproposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& AcceptResponseMessage::preparedproposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AcceptResponseMessage.preparedProposal)
  return _internal_preparedproposal();
}
inline void AcceptResponseMessage::unsafe_arena_set_allocated_preparedproposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.preparedproposal_);
  }
  _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.AcceptResponseMessage.preparedProposal)
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::release_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* released = _impl_.preparedproposal_;
  _impl_.preparedproposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::unsafe_arena_release_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AcceptResponseMessage.preparedProposal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* temp = _impl_.preparedproposal_;
  _impl_.preparedproposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::_internal_mutable_preparedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.preparedproposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.preparedproposal_;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::mutable_preparedproposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_preparedproposal();
  // @@protoc_insertion_point(field_mutable:spectrum.AcceptResponseMessage.preparedProposal)
  return _msg;
}
inline void AcceptResponseMessage::set_allocated_preparedproposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.preparedproposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.preparedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.AcceptResponseMessage.preparedProposal)
}

// .spectrum.ProposalMessage acceptedProposal = 3;
inline bool AcceptResponseMessage::has_acceptedproposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceptedproposal_ != nullptr);
  return value;
}
inline void AcceptResponseMessage::clear_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.acceptedproposal_ != nullptr) _impl_.acceptedproposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spectrum::ProposalMessage& AcceptResponseMessage::_internal_acceptedproposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.acceptedproposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& AcceptResponseMessage::acceptedproposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AcceptResponseMessage.acceptedProposal)
  return _internal_acceptedproposal();
}
inline void AcceptResponseMessage::unsafe_arena_set_allocated_acceptedproposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceptedproposal_);
  }
  _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.AcceptResponseMessage.acceptedProposal)
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::release_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* released = _impl_.acceptedproposal_;
  _impl_.acceptedproposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::unsafe_arena_release_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AcceptResponseMessage.acceptedProposal)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spectrum::ProposalMessage* temp = _impl_.acceptedproposal_;
  _impl_.acceptedproposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::_internal_mutable_acceptedproposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.acceptedproposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.acceptedproposal_;
}
inline ::spectrum::ProposalMessage* AcceptResponseMessage::mutable_acceptedproposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_acceptedproposal();
  // @@protoc_insertion_point(field_mutable:spectrum.AcceptResponseMessage.acceptedProposal)
  return _msg;
}
inline void AcceptResponseMessage::set_allocated_acceptedproposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.acceptedproposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.acceptedproposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.AcceptResponseMessage.acceptedProposal)
}

// int64 epoch = 4;
inline void AcceptResponseMessage::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t AcceptResponseMessage::epoch() const {
  // @@protoc_insertion_point(field_get:spectrum.AcceptResponseMessage.epoch)
  return _internal_epoch();
}
inline void AcceptResponseMessage::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:spectrum.AcceptResponseMessage.epoch)
}
inline ::int64_t AcceptResponseMessage::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void AcceptResponseMessage::_internal_set_epoch(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// int64 maxSequenceNumber = 5;
inline void AcceptResponseMessage::clear_maxsequencenumber() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxsequencenumber_ = ::int64_t{0};
}
inline ::int64_t AcceptResponseMessage::maxsequencenumber() const {
  // @@protoc_insertion_point(field_get:spectrum.AcceptResponseMessage.maxSequenceNumber)
  return _internal_maxsequencenumber();
}
inline void AcceptResponseMessage::set_maxsequencenumber(::int64_t value) {
  _internal_set_maxsequencenumber(value);
  // @@protoc_insertion_point(field_set:spectrum.AcceptResponseMessage.maxSequenceNumber)
}
inline ::int64_t AcceptResponseMessage::_internal_maxsequencenumber() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxsequencenumber_;
}
inline void AcceptResponseMessage::_internal_set_maxsequencenumber(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.maxsequencenumber_ = value;
}

// -------------------------------------------------------------------

// AbortRequestMessage

// string acceptorId = 1;
inline void AbortRequestMessage::clear_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.ClearToEmpty();
}
inline const std::string& AbortRequestMessage::acceptorid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AbortRequestMessage.acceptorId)
  return _internal_acceptorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AbortRequestMessage::set_acceptorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:spectrum.AbortRequestMessage.acceptorId)
}
inline std::string* AbortRequestMessage::mutable_acceptorid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acceptorid();
  // @@protoc_insertion_point(field_mutable:spectrum.AbortRequestMessage.acceptorId)
  return _s;
}
inline const std::string& AbortRequestMessage::_internal_acceptorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptorid_.Get();
}
inline void AbortRequestMessage::_internal_set_acceptorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptorid_.Set(value, GetArena());
}
inline std::string* AbortRequestMessage::_internal_mutable_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.acceptorid_.Mutable( GetArena());
}
inline std::string* AbortRequestMessage::release_acceptorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AbortRequestMessage.acceptorId)
  return _impl_.acceptorid_.Release();
}
inline void AbortRequestMessage::set_allocated_acceptorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptorid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acceptorid_.IsDefault()) {
          _impl_.acceptorid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spectrum.AbortRequestMessage.acceptorId)
}

// .spectrum.ProposalMessage proposal = 2;
inline bool AbortRequestMessage::has_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposal_ != nullptr);
  return value;
}
inline void AbortRequestMessage::clear_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.proposal_ != nullptr) _impl_.proposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spectrum::ProposalMessage& AbortRequestMessage::_internal_proposal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::spectrum::ProposalMessage* p = _impl_.proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::spectrum::ProposalMessage&>(::spectrum::_ProposalMessage_default_instance_);
}
inline const ::spectrum::ProposalMessage& AbortRequestMessage::proposal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:spectrum.AbortRequestMessage.proposal)
  return _internal_proposal();
}
inline void AbortRequestMessage::unsafe_arena_set_allocated_proposal(::spectrum::ProposalMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proposal_);
  }
  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spectrum.AbortRequestMessage.proposal)
}
inline ::spectrum::ProposalMessage* AbortRequestMessage::release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* released = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::spectrum::ProposalMessage* AbortRequestMessage::unsafe_arena_release_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:spectrum.AbortRequestMessage.proposal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spectrum::ProposalMessage* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
  return temp;
}
inline ::spectrum::ProposalMessage* AbortRequestMessage::_internal_mutable_proposal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::spectrum::ProposalMessage>(GetArena());
    _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(p);
  }
  return _impl_.proposal_;
}
inline ::spectrum::ProposalMessage* AbortRequestMessage::mutable_proposal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::spectrum::ProposalMessage* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:spectrum.AbortRequestMessage.proposal)
  return _msg;
}
inline void AbortRequestMessage::set_allocated_proposal(::spectrum::ProposalMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::spectrum::ProposalMessage*>(_impl_.proposal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::spectrum::ProposalMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.proposal_ = reinterpret_cast<::spectrum::ProposalMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:spectrum.AbortRequestMessage.proposal)
}

// -------------------------------------------------------------------

// AbortResponseMessage

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace spectrum


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_spectrum_2eproto_2epb_2eh
